--- sg16lan.c	2006-12-25 08:36:37.000000000 +0600
+++ sg16lan.c-new	2006-12-25 10:12:08.381749424 +0600
@@ -432,7 +432,7 @@
 	memset( &nl->stats, 0, sizeof(struct net_device_stats) );
 	memset( &nl->in_stats, 0, sizeof(struct sg16_stats) );
 
-	nl->head_xq = nl->tail_xq = nl->head_rq = nl->tail_rq = 0;
+
 
 	if( nl->state == NOT_LOADED ) {
 		printk( KERN_ERR "%s: firmware wasn't loaded\n", dev->name );
@@ -441,7 +441,6 @@
 
 	nl->regs->IMR = EXT;
 	nl->regs->SR = 0xff;
-	nl->regs->CR  |= TXEN | RXEN;	
 
 	t=0;
 	if( issue_cx28975_cmd(nl,_DSL_RESET_SYSTEM,&t,1) )
@@ -458,11 +457,16 @@
 		return  -EIO;
 
 	// start transmission through interface
+
+	nl->head_xq = nl->tail_xq = nl->head_rq = nl->tail_rq = 0;	
+	nl->head_tdesc = nl->head_rdesc = 0;	
+	nl->regs->CR  |= TXEN | RXEN;		
 	nl->regs->CTDR = nl->regs->LTDR = nl->regs->CRDR = nl->regs->LRDR = 0;	
-	nl->head_tdesc = nl->head_rdesc = 0;
+/*DEBUG*/
+memset(nl->rq,0,sizeof(struct sk_buff)*RQLEN);
+/*-----*/
 	alloc_rx_buffers( dev );
 	netif_wake_queue( dev );	
-
 	return 0;
 }
 
@@ -989,6 +993,8 @@
 {
         struct net_local  *nl  = (struct net_local *)netdev_priv(ndev);
         struct sk_buff *skb = nl->rq[ elem ];
+	if( !skb )
+		return 0;
 	PDEBUG(recv_debug,"start,elem=%d",elem);		
         if( (nl->dev_type == sg16isa) &&
                     (virt_to_bus(skb->data)+skb->len > ISA_DMA_MAXADDR) ){
@@ -1005,7 +1011,7 @@
         struct net_local  *nl  = (struct net_local *)netdev_priv(ndev);
         struct dma_buffer *b = (struct dma_buffer *)nl->rbuf + elem;
         if( (nl->dev_type == sg16isa) &&
-                virt_to_bus(skb->data)+skb->len > ISA_DMA_MAXADDR ){
+                (virt_to_bus(skb->data)+skb->len > ISA_DMA_MAXADDR) ){
 		PDEBUG(recv_debug,"need to use ext buffer");
                 return (void*)b->buff;
 	}
@@ -1023,8 +1029,16 @@
 
 	while( nl->tail_rq != ((nl->head_rq - 1) & (RQLEN - 1)) ) {
 		struct sk_buff  *skb = dev_alloc_skb( ETHER_MAX_LEN );
+		if( !skb ){
+			printk(KERN_NOTICE"%s: no memory\n",__FUNCTION__);
+			return;
+		} 
 		skb->dev = dev;
 		skb_reserve( skb, 2 );	/* align ip on longword boundaries */
+/*DEBUG*/		
+if( nl->rq[ nl->tail_rq ] != 0 )
+	printk(KERN_NOTICE"nl->rq[ %d ]!= NULL\n",__FUNCTION__,nl->tail_rq );
+/*-----*/	
 		cpu_addr=recv_skb_to_dma(dev,skb,nl->tail_rq);		
 		nl->rq[ nl->tail_rq++ ] = skb;
 		nl->tail_rq &= (RQLEN - 1);
@@ -1048,10 +1062,19 @@
 		len = nl->rbd[ nl->head_rdesc ].length & 0x7ff;
 		if( len < ETHER_MIN_LEN )
 			len = ETHER_MIN_LEN;
+		else if( len > ETHER_MAX_LEN ){
+			printk(KERN_NOTICE"%s: error len=%d\n",__FUNCTION__,len);
+			goto next_pkt;
+		}
 		skb=recv_skb_sync_one(dev,len,nl->head_rq);
-		nl->head_rq++;
-		nl->head_rq &= (RQLEN - 1);
-		
+		if( !skb ){
+			printk(KERN_NOTICE"%s: skb=NULL\n",__FUNCTION__);
+			goto next_pkt;
+		}
+/*DEBUG*/
+nl->rq[ nl->head_rq ]=0;
+/*-----*/
+
 		skb_put( skb, len );
 		skb->protocol = eth_type_trans( skb, dev );
 		netif_rx( skb );
@@ -1059,8 +1082,11 @@
 		++nl->in_stats.rcvd_pkts;
 		++nl->stats.rx_packets;
 		nl->stats.rx_bytes += len;
-
+next_pkt:
 		nl->head_rdesc = (nl->head_rdesc + 1) & 0x7f;
+		nl->head_rq++;
+		nl->head_rq &= (RQLEN - 1);
+		
 	}
 }
 
@@ -1068,7 +1094,9 @@
 drop_rq( struct net_local *nl )
 {
 	while( nl->head_rq != nl->tail_rq ) {
-		dev_kfree_skb_any( nl->rq[ nl->head_rq++ ] );
+		dev_kfree_skb_any( nl->rq[ nl->head_rq ] );
+		nl->rq[ nl->head_rq ] = 0;
+		nl->head_rq++;
 		nl->head_rq &= (RQLEN - 1);
 	}
 }
